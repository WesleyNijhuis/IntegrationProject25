close all; clear; clc;

%% Loading acquired data
load('../Data/Sweep1 alpha.mat');   % loading alpha's
load('../Data/Sweep1 theta.mat');   % loading theta's
load('../Data/Sweep1 input.mat');   % loading inputs

Y = [alpha; theta].'; 
ymeas = Y(:);
u = uin.';            

%% Initial guess can be entered in the function theta2matrices!
%function [theta_init] = initialguess(mp,L)

%% Splitting into training/validation set
f_t = 0.7;                 % fraction of data dedicated to training
ut = u(1:end*f_t);            % input for train-set
uv = u(end*f_t+1:end);          % input for validation-set

yt = ymeas(1:end*f_t);        % output for train-set
yv = ymeas(end*f_t+1:end);      % output for validation-set
%% Run Algorithm
rng(1,"twister");
theta_init = - 0.5 * abs(rand(8,1));

% Set 1
[A0, B0, C0, D0, x00] = theta2matrices(theta_init);

lambda = 4 * 1e-1;
maxiter = 200;

disp('Results theta 1, set 1')
[Abar,Bbar,C,D,x0, J, H] = pem(theta_init,A0,B0,C0,D0,x00,yt,ut,lambda,maxiter) 

%% Parameters to state matrices
function [Abar,Bbar,C,D,x0] = theta2matrices(theta)
%%
% Function INPUT
% theta Parameter vector (vector of size: according to the realization)
%
%
% Function OUTPUT
% Abar System matrix A (matrix of size n x n)
% Bbar System matrix B (matrix of size n x m)
% C System matrix C (matrix of size l x n)
% D System matrix D (matrix of size l x m)
% x0 Initial state (vector of size n x one)

Abar=[[0, 0, 1, 0]; [0, 0, 0, 1]; [0, theta(1), theta(3), theta(5)]; [0, theta(2), theta(4), theta(6)]] 
Bbar=[0 ; 0; theta(7); theta(8)]; C=[[1, 0, 0, 0];[0, 1, 0, 0]]; D=[0]
x0=[0; 0; 0; 0]
end

%% Simulating systems
function [y, x] = simsystem(A, B, C, D, x0, u)
% Instructions:
% Simulating a linear dynamic system given input u, matrices A,B,C,D ,and
% initial condition x(0)
%
% n = size(A, 1);
% m = size(B, 2);
% l = size(C, 1);
% N = size(u, 1);
%
% Function INPUT
% A system matrix (matrix of size n x n)
% B system matrix (matrix of size n x m)
% C system matrix (matrix of size l x n)
% D system matrix (matrix of size l x m)

% x0 initial state (vector of size n x one)
% u system input (matrix of size N x m)
%
% Function OUTPUT
% x state of system (matrix of size N x n)
% y system output (matrix of size N x l)
x(1,:) = x0';
%%%%%% YOUR CODE HERE %%%%%%
y = zeros(max(size(u,1), size(u,1)), 1);
for k=1:size(u,1)
 x(k+1, :) = x(k, :) * A.' + u(k) * B.'; % Transposed state equation
 y(k) = x(k, :) * C.' + u(k) * D.';
end
x=x(1:end -1, :); % removing the last entry to get Nxn x()
end

%% Computing Jacobian for optimization
function J = jacobian(psi,E)
% Instructions:
% This function calculates the Jacobian vector in the Gauss-Newton
% algorithm
%
% p = size(theta);
% N = size(y, 1);
% l = size(C, 1);
%
% Function INPUT
% psi derivative of estimation error wrt theta (matrix of size l*N x p)
% E estimation error vector (vector of size l*N x one)
%
% Function OUTPUT
% J Jacobian vector (vector of size p x one)
%%%%%% YOUR CODE HERE %%%%%%
J = 2 * psi.' * E / size(E, 1);
end

%% Computing Hessian for optimization
function H = hessian(psi)
% Instructions:
% This function calculates the approximated Hessian matrix in the Gauss-Newton
% algorithm
%
% p = size(theta);
% N = size(y, 1);
% l = size(C, 1);
%
% Function INPUT
% psi derivative of estimation error wrt theta (matrix of size l*N x p)
%
% Function OUTPUT
% H Hessian matrix (matrix of size p x p)
%%%%%% YOUR CODE HERE %%%%%%
H = 2 * psi.' * psi / size(psi, 1);
end

%% PEM algorithm

function [Abar,Bbar,C,D,x0, J, H] = pem(theta,A0,B0,C0,D0,x00,y,u,lambda,maxiter)
% Instructions:
% Implement your Prediction Error Method for the Output Error system here.
% Use the following function inputs and outputs.
%
% Function INPUT
% theta  Paramter vector (size: depends on your mapping choice)
% A0 Initial guess for system matrix A (matrix of size n x n)
% B0 Initial guess for system matrix B (matrix of size n x m)
% C0 Initial guess for system matrix C (matrix of size l x n)
% D0 Initial guess for system matrix D (matrix of size l x m)
% x00 Initial guess for initial state (vector of size n x one)
% u System input (matrix of size N x m)
% y System output (matrix of size N x l)
% lambda regularization parameter (scalar)
% maxiter Maximum number of iterations (scalar)
%
%
% Function OUTPUT
% Abar Estimate of system matrix A (matrix of size n x n)
% Bbar Estimate of system matrix B (matrix of size n x m)
% C Estimate of system matrix C (matrix of size l x n)
% D Estimate of system matrix D (matrix of size l x m)
% x0 Estimate of initial state (vector of size n x one)


%%%%%% YOUR CODE HERE %%%%%%

N = size(u, 1);
P = size(theta, 1);
n = size(A0, 2);
lN = size(y, 1);

% hier jacobians van de matrices definieren

dA(:,:,1) = [0, 0, 0, 0;
             0, 0, 0, 0;
             0, 1, 0, 0;
             0, 0, 0, 0];

dA(:,:,2) = [0, 0, 0, 0;
             0, 0, 0, 0;
             0, 0, 0, 0;
             0, 1, 0, 0];

dA(:,:,3) = [0, 0, 0, 0;
             0, 0, 0, 0;
             0, 0, 1, 0;
             0, 0, 0, 0];

dA(:,:,4) = [0, 0, 0, 0;
             0, 0, 0, 0;
             0, 0, 0, 0;
             0, 0, 1, 0];

dA(:,:,5) = [0, 0, 0, 0;
             0, 0, 0, 0;
             0, 0, 0, 1;
             0, 0, 0, 0];

dA(:,:,6) = [0, 0, 0, 0;
             0, 0, 0, 0;
             0, 0, 0, 0;
             0, 0, 0, 1];

for q=7:8
    dA(:,:,q) = zeros(4,4);
end

for q=1:6
    dB(:, q) = zeros(4,1);
end

dB(:, 7) = [0; 0; 1; 0];

dB(:, 8) = [0; 0; 0; 1];

dC =zeros(2,8);
dD =0;

X0 = zeros(4,8);

X = zeros(N, n, P); % number of x parameters
X(1, :, :) = X0;
dy_hat = zeros(lN, P);


% Gauss-Newton

% initialize
converged = false;
maxiter_reached = false;
iter = 1;

while ~converged && ~maxiter_reached 


    %%%%%% YOUR CODE HERE %%%%%%

    warning('off')
    for i=1:maxiter
        
        % Step 1: constructing estimates for state matrices
        [Abar,Bbar,C,D,x0] = theta2matrices(theta);

        % Step 2: simulating system to obtain estimates of x and y
        [y_hat, x_hat] = simsystem(Abar, Bbar, C, D, x0, u);

        % Step 3: simulating a linear system to obtain dx_hat/dtheta and
        % dy_hat/dtheta
        
        for p=1:P%k=1:N
            for k=1:N%p=1:P
                
                X(k+1,:, p) = X(k,:, p) * Abar.' + x_hat(k,:) * dA(:,:,p).'  + u(k) * dB(:, p).'; % (Transposed) state equations

                dy_hat(k, p) = X(k,:, p) * C.' + x_hat(k,:) * dC.' + u(k) * dD.';

            end
        end

        %X = X(1:end-1, :, :); % TODO check of dit nodig is
        
        % Step 4: using y_hat from step 2 to calculate E
        E = y - y_hat;

        % Step 5: using dy_hat from step 3 to calculate psi
        psi = -dy_hat;
        
        % Step 6: using psi and E to calculate Hessian and Jacobian
        H = hessian(psi);
        J = jacobian(psi, E);

        % Step 7: update the estimate for theta
        theta_new = theta - ((H + lambda * speye(P, P)) \ J); %HOE bepaal je laatste 4 parameters; x0?
        
    end
    
    warning('on')

    % Check convergence
    if norm(theta_new - theta) < 1e-3 
        converged = true; 
    elseif iter == maxiter 
        maxiter_reached = true; 
        warning('Maximum iterations reached'); 
    end
    theta = theta_new; 
    iter = iter + 1;
end

disp('final J_N = ')
disp(E.' * E / N)

%%%%%% YOUR CODE HERE %%%%%%


     
end