close all; clear; clc;

%% Loading acquired data
training_data_y = cell(1,2);
training_data_u = cell(1,2);

%training set 2: square sweep
load('../Data/Squaresweep 1 alpha.mat');   % loading alpha's
load('../Data/Squaresweep 1 theta.mat');   % loading theta's
load('../Data/Squaresweep 1 input.mat');   % loading inputs
alpha = alpha(:,2);
theta = theta(:,2);

data_end = 12000;
data_begin = 1;
ymeas = [alpha(data_begin:data_end), theta(data_begin:data_end)];
uin = u(data_begin:data_end,2);   

for i=1:length(uin)
    if uin(i)>= 0
        uin(i) =+ 0.0023;
    else 
        uin(i) =- 0.0023;
    end
end

training_data_y{2} = ymeas;
training_data_u{2} = uin;

%training set 1: sweep
load('../Data/Sweep 8 alpha.mat');   % loading alpha's
load('../Data/Sweep 8 theta.mat');   % loading theta's
load('../Data/Sweep 8 input.mat');   % loading inputs
alpha = alpha(:,2);
theta = theta(:,2);

data_end = 12000;
data_begin = 1;
ymeas = [alpha(data_begin:data_end), theta(data_begin:data_end)];
uin = u(data_begin:data_end,2);     

training_data_y{1} = ymeas;
training_data_u{1} = uin;

dt = 0.01;
t = 0:dt:(data_end - data_begin)*dt;

%% Singular values
 s = 100;
 y_hank = hankel(ymeas(1:s),ymeas(s:end));
 [U,S,V] = svd(y_hank, 'econ');
 sing_vals = diag(S);
 figure
 semilogy(sing_vals,'o')
 grid on
 title('Singular values of the output signal')
 xlabel('Value index')
 ylabel('Singular value')

%% Run Algorithm
close all

% Testing different sizes
n=4;
A0 = ones(n,n);
B0 = ones(n,1);
C0 = ones(2,n);
D0 = zeros(2,1);

% check P.E.O.
%checkpoe(n, training_data_u{1},t,s)

% PEM DT
%K = zeros(4,1); % no kalman observer for now: add later
%T_s = 0.01; % sampling time
init_sys = idss(A0, B0, C0, D0); %x0 is 0
%init_sys.x0 = x00;
init_sys.Ts = 0;

training_data = iddata(training_data_y,training_data_u,dt);
opt = ssestOptions('Display','on','SearchMethod','gna');
opt.SearchOptions.MaxIterations = 4000;
opt.SearchOptions.Tolerance = 1e-12;
opt.InitialState = 'zero';
%opt.OutputOffset = [mean(ymeas(:,1));mean(ymeas(:,2))]; %CHECK IF THIS WORKS BETTER
opt.N4Weight = 'MOESP';
opt.N4Horizon = [s/2 s/2 s/2]; % s = 60, symmetric Yo Yf
opt.EnforceStability = true;
opt.Advanced.DDC = 'on';
sys_init2 = n4sid(training_data, init_sys,opt);
sys_init2.Ts = 0;

%opt.Regularization.Lambda = 1e-6;
%opt.Regularization.Nominal = 'zero'; % prefer low entries in matrices for controller implementation and num. stability

sys = sys_init2; % pem(training_data, sys_init2,opt);

disp('Results theta 1, set 1')
Abar = sys.A
Bbar = sys.B
Cbar = sys.C
D = sys.D
sys.x0 = zeros(n,1);

Config = RespConfig(Amplitude=0.01,Delay=2);
figure()
impulse(sys, Config)

eig(sys.A)

figure()
ropt = residOptions;
ropt.MaxLag = 100;
resid(training_data, sys,ropt)
%% Enforcing structure via state coordinate transformation (T = [C;CA])

T = [sys.C;sys.C*sys.A];
Ds = sys.D;
Cs = sys.C/T;
Bs = T*sys.B;
As = T*sys.A/T;

semi_struct_sys = ss(As,Bs,Cs,Ds);

%% Conditioning B to be [0;0;*;*]
close all

corrected_B = semi_struct_sys.B;
corrected_B(1) = 0;
corrected_B(2) = 0;

Acorr = semi_struct_sys.A;

Acorr(4,1) = 0;
Acorr(3,1) = 0;

sys_init3 = idss(Acorr,corrected_B,semi_struct_sys.C,semi_struct_sys.D);
sys_init3.Ts = 0;

sys_init3.Structure.A.Free = [[0,0,0,0];
                             [0,0,0,0];
                             [0,1,1,1]; %A31 is a torsional factor induced by cable
                             [0,1,1,1]]; % only the parameter entries (1 or 'True') can be changed
sys_init3.Structure.B.Free = [0;0;1;1];
sys_init3.Structure.C.Free = zeros(2,4);
sys_init3.Structure.D.Free = [0;0];


struct_sys = pem(training_data, sys_init3,opt);

figure()
impulse(struct_sys)

figure()
resid(training_data, struct_sys,ropt)

%% Validation (for every test do two runs)

load('../Data/Squaresweep 2 alpha.mat');   % loading alpha's
load('../Data/Squaresweep 2 theta.mat');   % loading theta's
load('../Data/Squaresweep 2 input.mat');   % loading inputs

alpha = alpha(:,2);
theta = theta(:,2);

data_end = 8000; %for debugging
data_begin = 1;
ymeas = [alpha(data_begin:data_end), theta(data_begin:data_end)];
uin = u(data_begin:data_end,2);     

for i=1:length(uin)
    if uin(i)>= 0
        uin(i) =+ 0.0023;
    else 
        uin(i) =- 0.0023;
    end
end

validation_data = [ymeas,uin];

figure()
compare(validation_data,sys, struct_sys)

figure()
resid(validation_data, struct_sys,ropt)

%% Discretize for implementation
str_discr_sys = c2d(struct_sys,0.01,'zoh');

%% Augment the system to achieve disturbance rejection
A_aug = [str_discr_sys.A,str_discr_sys.B;
        zeros(1,n), 1];
B_aug = [str_discr_sys.B;0];
C_aug = [str_discr_sys.C, zeros(2,1)];
D_aug = str_discr_sys.D;
sys_aug = ss(A_aug,B_aug,C_aug,D_aug,dt);

%% Discrete Iterative Kalman Filter Design
close all

u_training = training_data_u{1};
y_training = training_data_y{1};
x_0 = [0;0;0;0;0];

y_est = lsim(sys_aug, u_training, t,x_0);

% estimate the variance
R1 = blkdiag(6 * 1e-6 * eye(4), 6*1e-2); % this is the model uncertainty
R2 = 1e-10 * eye(2); % this is the measurement uncertainty
R12 = zeros(5,2);

kalman_observer = ss(sys_aug.A,[sys_aug.B eye(n+1)],sys_aug.C,[sys_aug.D zeros(2,5)]);
[Kest,L,P] = kalman(kalman_observer, R1, R2)

% redefine system

K_sys = Kest;

% test results
yest_k = lsim(K_sys, [u_training,y_training], t,x_0);
epsilon = y_training - yest_k(:,1:2);

var =  epsilon.' * epsilon

figure()
title('alpha')
plot(y_training(:,1), 'r:')
hold on
plot(y_est(:,1), 'b:')
plot(yest_k(:,1))
hold off
legend('y_training','yest','yest_k')

%% (DISCRETE VERSION) - Manual LQ(G)R design
close all

Q = diag([1, 5, 0, 0]); 
R = [1e-1];
[P, K, cl_eig] = idare(str_discr_sys.A, str_discr_sys.B, Q, R)

K_aug = [K, 1]; % Kw = 1 perfectly cancels the disturbance!

% %solve regulation
% Br = zeros(4,2);
% Dr = [-1,0;0,0];
% [Pi,Gamma,Gstar] = SolveReg(str_discr_sys.A,str_discr_sys.B,str_discr_sys.C,str_discr_sys.D,Br,Dr,Kstar)

lqgsys = sys_aug % printing original matrices
lqgsys.A = sys_aug.A - sys_aug.B*K_aug;
DC_gain = dcgain(lqgsys); 
lqgsys.B = lqgsys.B/DC_gain(1);

figure()
step(lqgsys) % note the steady state error in theta

%% Augmenting system again to add integral action on theta to achieve zero steady state error
C_theta = [0,1,0,0];
A_int = [str_discr_sys.A,zeros(4,1);C_theta,1];
B_int = [str_discr_sys.B;0];
C_int = [str_discr_sys.C,zeros(2,1)];
D_int = str_discr_sys.D;

sys_int = ss(A_int,B_int,C_int,D_int,dt);

% figure()
% pzplot(lqgsys)
% 
% [~,tstep,xstep] = step(lqgsys);
% figure()
% plot(tstep,xstep)
% legend('alpha','theta','alpha_dot','theta_dot','d')
% grid on
% 
% x01 = [2;2;1;1;2];
% [y1,tout1,x1] = lsim(lqgsys,ones(200,1),t(1:200),x01);
% x02 = [2;2;1;1;0];
% [y2,tout2,x2] = lsim(lqgsys,ones(200,1),t(1:200),x02);
% 
% figure()
% plot(tout1,x1)
% 
% figure()
% plot(x1(:,2), 'r')
% hold on
% plot(x2(:,2), 'b--')
% hold off
% legend('disturbed','undisturbed')
% grid on
% 
% stepinfo(lqgsys).TransientTime
% [~,~,x] = step(lqgsys);
% 
% figure()
% plot(K_aug*x.');
% grid on
% u_max = max(abs(K_aug*x.'));

%% (Continuous VERSION) - Manual LQR design
close all

Q = diag([1, 1, 1, 1]);
R = [1e3];
[P, K, cl_eig] = icare(struct_sys.A, struct_sys.B, Q, R)

clqsys = struct_sys % printing original matrices
clqsys.A = struct_sys.A - struct_sys.B*K;
DC_gain = dcgain(clqsys);
G = 1/DC_gain(1);
clqsys.B = G*clqsys.B;

figure()
pzplot(clqsys)

figure()
step(clqsys)
grid on

stepinfo(clqsys).TransientTime
[~,~,x] = step(clqsys);

figure()
plot(K*x.');
grid on
u_max = max(abs(K*x.'));

%% (Discrete VERSION) - Optimal LQR syntesis using genetic algorithm
close all

function [u_max, overshoot,settling_time, rise_time, f_fp] = results_d(system,K,dt)
% K is the resulting stabilizing feedbackgain from ARE
% system is the uncontrolled system of interest

system.A = system.A - system.B*K; % A-> Ak

DC_gain = dcgain(system); 
system.B = system.B / DC_gain(1); % xdot = Ak x + BG r 

info = stepinfo(system);
settling_time = [info.TransientTime].';
overshoot = [info.Overshoot].' + [info.Undershoot].';
rise_time = [info.RiseTime].';
[~,~,x] = step(system);
u_max = max(abs(1/DC_gain(1) - K*x.')); % step (1*G=1/DC_gain) + control inputs (Kx)
f_fp = max(abs(log(pole(system))/dt));
end

function f = evaluate_d(W, system,V,n,dt)
% W is a 1x3 vector of weights
% V = [q1 q2 ... r]
Q = diag(V(1:n));
R = 1;
[~, K, ~] = idare(system.A, system.B, Q, R);

[u_max, overshoot,settling_time, rise_time, f_fp] = results_d(system,K,dt);
%penalty = 1e6 / (1 + exp(-100*(u_max - 0.8)));
penalty = 1e5*max(0, u_max - 2)^2 + 1e5*max(0, f_fp - 80)^2; % restrict the input to X and the fastest pole to X rad/s

f = W(1)*u_max+[W(2), W(3)]*overshoot+[W(4) W(5)]*settling_time + W(6)*f_fp + penalty;
end

% LQR optimization
W = [0.01,0,0.001,0,1,0.01]; % {input | alpha overhoot | theta overshoot | alpha ts | theta ts | fastest pole coeficient}

lb = zeros(1,n);
ub = [];     
V = optimvar('V',1,n,'LowerBound',0);
evaluateFcn = @(V) evaluate_d(W,str_discr_sys,V,n,dt);
est_max_V = 1e-2;
initrange = [0,0,0,0;est_max_V,est_max_V,est_max_V,est_max_V];
options = optimoptions('ga','FunctionTolerance',1e-8, "UseParallel", ...
    true, "PopulationSize", 80, "EliteCount", 10, 'InitialPopulationRange',initrange,'PlotFcn', @gaplotbestf, ...
    MaxGenerations = 500, Display = "iter");
[sol,val] = ga(evaluateFcn, n, [], [], [], [], lb, ub, [], options);

Q = diag(sol(1:n));
R = 1;

[~,Kstar,~] = idare(str_discr_sys.A,str_discr_sys.B,Q,R)

%solve regulation
Br = zeros(4,1);
Dr = [-1;0];
[Pi,Gamma,Gstar] = SolveReg(str_discr_sys.A,str_discr_sys.B,str_discr_sys.C,str_discr_sys.D,Br,Dr,Kstar)

str_discr_sys
olqsys = str_discr_sys;
olqsys.A = str_discr_sys.A - str_discr_sys.B*Kstar;
olqsys.B = olqsys.B * Gstar;

figure()
step(olqsys)
grid on

figure()
pzplot(olqsys)
grid on

DC_gain(1)

%% (DISCRETE VERSION) - pole placement design
%poles = [0.4,0.45,0.9898 + 0.0037i,0.9898 - 0.0037i,0.5]
poles = [0.96,0.97,0.98,0.9];
K = place(str_discr_sys.A, str_discr_sys.B, poles)

sfsys = str_discr_sys % printing original matrices
sfsys.A = sfsys.A - sfsys.B*K;
DC_gain = dcgain(sfsys);
G = 1/DC_gain(1);
sfsys.B = G*sfsys.B;
%pzplot(lqsys)
Config = RespConfig(Amplitude=1,Delay=0);
step(sfsys, Config)
grid on
stepinfo(sfsys).TransientTime
stepinfo(sfsys).Overshoot

%% compare results
figure()
title('Comparison of tuning methods')
step(olqsys)
hold on
step(lqsys)
step(sfsys)
hold off
legend('Optimal LQ','Manual LQ', 'Manual pole-placement')
grid on

% %% Transform system to CT for parameters
% 
% sys_c = d2c(sys,'zoh');
% impulse(sys_c)
% hold on
% impulse(sys)
% hold off
% legend()

%% Debugging
t_test = 0:0.01:120;
utest = 0.005 * chirp(t_test,0.1,120,5);
lsim(sys,utest,t_test)
%plot(utest)

%% T = [C;CA] from observability matrix!!

T = [sys.C;sys.C*sys.A];
Ds = sys.D;
Cs = sys.C/T
Bs = T*sys.B
As = T*sys.A/T

struct_sys = ss(As,Bs,Cs,Ds);

t_test = 0:0.01:120;
utest = 0.005 * chirp(t_test,0.1,120,5);
lsim(sys,utest,t_test)
legend('structured system response')

%% persistancy of excitation rank condition
function checkpoe(n, inputs,t,s)
    % this function checks if the persistency of excitation rank condition
    % is fulfilled

    % inputs: system of interest, inputs used for id, timeline and used
    % horizon s
    % inputs is N x m
    % output: error if condition not fulfilled

    u_hank = hankel(inputs(1:2*s),inputs(2*s:end));
    
    r = rank([u_hank]);
    m = size(inputs,2);

    if r >= n+2*s & s*m > 10*n
        display('rank condition probably fulfilled, input persistently exciting')
    else
        str = "rank condition probably not fulfilled, input not persistently exciting as rank of u_hankel is " + r + " instead of "+(n+2*s);
        error(str)
    end
end

%% Regulator equation solver for alpha tracking r
function [Pi,Gamma,G] = SolveReg(A,B,Ctilde,Dtilde,Br,Dr,K)
    M = [eye(size(A,1)) - A,-B;Ctilde-Dtilde*K,zeros(size(Ctilde,1),size(B,2))];
    N = [Br;Dr];

    sol = M\N;
    Pi = sol(1:size(A,2),:);
    Gamma = sol(size(A,2)+1:end,:);

    G = Gamma + K*Pi;
end